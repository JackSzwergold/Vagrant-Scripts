input {

  file {
    path => "/home/vagrant/deploy_items/data/dump_logstash_data/access_log*"
    start_position => "beginning"
  }

}

filter {

  if [path] =~ "access" {

    mutate {
      replace => {
        "type" => "apache_access"
      }
    }

    grok {
      match => {
        "message" => "%{COMBINEDAPACHELOG}"
      }
    }

    # URL decode all existing fields.
    urldecode {
      all_fields => true
    }

    # Prune the values so only this specific set of fields goes through.
    prune {
      whitelist_names => [ "clientip", "referrer", "bytes", "agent", "response", "request", "ident", "host", "httpversion", "message", "verb",  "auth" ]
    }

    # Split based on key values. Note the 'include_keys' which restricts what is parsed from the 'request' source value.
    kv {
      source => "request"
      field_split => "&?"
      allow_duplicate_values => false
      include_keys => [ "mode", "ctitle", "query", "page", "crse_id", "crn", "sec", "campus", "format", "subject", "degree", "libarts", "gradlevel", "topic", "college", "department", "days", "times", "term", "status" ]
      prefix => "cc_"
    }

    # Handle nice URL values for the '/courses/' path.
    grok {
      match => {
        "request" => [
          "/courses/%{WORD:cc_crse_id}/%{INT:cc_crn}",
          "/courses/%{WORD:cc_crse_id}"
        ]
      }
      tag_on_failure => []
    }

    # If we have somehow captured an old URL with the 'sec' parameter, convert that to a 'crn'.
    if [cc_sec] =~ /.+/ {
      mutate {
        add_field => { "cc_crn" => "%{[cc_sec]}" }
        remove_field => [ "cc_sec" ]
      }
    }

    # Use 'mutate' to convert, remove extra characters and trim whitespace from specific fields.
    mutate {
      convert => {
        "bytes" => "integer"
        "response" => "integer"
        "cc_crn" => "integer"
        "cc_page" => "integer"
        "cc_term" => "integer"
      }
      gsub => [ "referrer", "\"", "" ]
      strip => [ "cc_mode", "cc_ctitle", "cc_query", "cc_page", "cc_crse_id", "cc_crn", "cc_sec", "cc_campus", "cc_format", "cc_subject", "cc_degree", "cc_libarts", "cc_gradlevel", "cc_topic", "cc_college", "cc_department", "cc_days", "cc_times", "cc_term", "cc_status" ]
    }

    # Set the GeoIP value based on the client IP address.
    geoip {
      source => "clientip"
    }

    # Set a fingerprint to avoid duplicate entries.
    fingerprint {
      source => "message"
      target => "[@metadata][fingerprint]"
      method => "MURMUR3"
    }

  }

  # Set the timestamp as an actual timestamp.
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  }

}

output {

  elasticsearch {
    hosts => ["localhost:9200"]
    index => "logstash-apache"
    document_id => "%{[@metadata][fingerprint]}"
    manage_template => false
    template => "/home/vagrant/deploy_items/confs/ubuntu/logstash/logstash-apache.json"
    template_name => "logstash-apache"
    template_overwrite => true
  }

  stdout {
    codec => rubydebug
  }

}
