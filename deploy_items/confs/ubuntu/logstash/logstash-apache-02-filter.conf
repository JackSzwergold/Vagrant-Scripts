filter {

  mutate {
    replace => {
      "type" => "apache_access"
    }
  }

  grok {
    match => {
      "message" => "%{COMBINEDAPACHELOG}"
    }
  }

  # URL decode all existing fields.
  urldecode {
    all_fields => true
  }

  # Drop entries that are empty.
  if [message] !~ /.+/ { drop { } }

  # If 'rawrequest' is set then make that the 'request' and remove the 'rawrequest'.
  if [rawrequest] =~ /.+/ {
    mutate {
      add_field => { "request" => "%{[rawrequest]}" }
      remove_field => [ "rawrequest" ]
    }
  }

  # Drop localhost and internal maintenance requests.
  if ([clientip] =~ /^localhost$|^127(?:\.[0-9]+){0,2}\.[0-9]+$|^(?:0*\:)*?:?0*1$/) { drop { } }

  # Drop entries that are just ancillary items; we only want pure request data.
  if ([request] =~ /(fonts|css|script|robots.txt|favicon.ico|wp-login.php)/) { drop { } }
  if ([request] =~ /^.*\.(png)$/) { drop { } }

  # Drop entries that have 2 or more dots in the request; those are clearly hacking attempts.
  if ([request] =~ /(\.{2}(\/|%2F)?)/) { drop { } }

  # Drop entries that have 2 or more backticks (grave accdents) in the request; those are clearly hacking attempts.
  if ([request] =~ /(`|%60){2}/) { drop { } }

  # Drop entries that have 2 or more dots in the request; those are clearly hacking attempts.
  if ([request] =~ /(passwd|boot.ini|win.ini|window.top|xss|file%3A%2F%2F%2F)/) { drop { } }

  # Prune the values so only this specific set of fields goes through.
  prune {
    whitelist_names => [ "timestamp", "clientip", "referrer", "bytes", "agent", "response", "request", "ident", "host", "httpversion", "message", "verb",  "auth" ]
  }

  # Split based on key values. Note the 'include_keys' which restricts what is parsed from the 'request' source value.
  kv {
    source => "request"
    field_split => "&?"
    allow_duplicate_values => false
    include_keys => [ "mode", "ctitle", "query", "page", "crse_id", "crn", "sec" ]
    include_keys => [ "campus", "format", "subject", "degree", "libarts", "gradlevel", "topic", "college", "department", "days", "times", "term", "status" ]
    include_keys => [ "campus[]", "format[]", "subject[]", "degree[]", "libarts[]", "gradlevel[]", "topic[]", "college[]", "department[]", "days[]", "times[]", "term[]", "status[]" ]
    prefix => "cc_"
  }

  # Handle nice URL values for the '/courses/' path.
  grok {
    match => {
      "request" => [
        "/courses/%{WORD:cc_crse_id}/%{INT:cc_crn}",
        "/courses/%{WORD:cc_crse_id}"
      ]
    }
    tag_on_failure => []
  }

  # If we have somehow captured an old URL with the 'sec' parameter, convert that to a 'crn'.
  if [cc_sec] =~ /.+/ {
    mutate {
      add_field => { "cc_crn" => "%{[cc_sec]}" }
      remove_field => [ "cc_sec" ]
    }
  }

  # Since fields with dashes are empty, let’s remove them.
  if [auth] == "-" {
    mutate {
      remove_field => [ "auth" ]
    }
  }

  # Since fields with dashes are empty, let’s remove them.
  if [ident] == "-" {
    mutate {
      remove_field => [ "ident" ]
    }
  }

  # Use 'mutate' to convert, remove extra characters and trim whitespace from specific fields.
  mutate {
    convert => {
      "bytes" => "integer"
      "response" => "integer"
      "cc_page" => "integer"
    }
    gsub => [ "referrer", "\"", "" ]
    strip => [ "cc_mode", "cc_ctitle", "cc_query", "cc_crse_id", "cc_campus", "cc_format", "cc_subject", "cc_degree", "cc_libarts", "cc_gradlevel", "cc_topic", "cc_college", "cc_department", "cc_days", "cc_times", "cc_status" ]
  }

  # Set the GeoIP value based on the client IP address.
  geoip {
    source => "clientip"
  }

  # Set a fingerprint to avoid duplicate entries.
  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MURMUR3"
    # method => "SHA256"
    # key => "apache_logs"
    # base64encode => true
  }

  ruby {

    code => "

      # Roll through these values and if anything is not an array value then set it as an array value.
      value_array = [ 'cc_campus', 'cc_format', 'cc_subject', 'cc_degree', 'cc_libarts', 'cc_gradlevel', 'cc_topic', 'cc_college', 'cc_department', 'cc_days', 'cc_times', 'cc_term', 'cc_status' ]
      value_array.each { |item|
        if (event.get(item) && !event.get(item).kind_of?(Array))
          event.set(item, [ event.get(item) ])
        end
      }

    "
  }

  # Set the timestamp as an actual timestamp.
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  }

}
